<html><head>	<title>Statements</title></head><body><h1>Statements</h1><p><a href="statementset.html" target="content">&lt; Show List</a></p><hr><h3><a name="let">{ let } VAR = EXPR</a></h3><p>Assign a value to a variable.  Variable names can be up to 31  significant characters, consisting of letters, digits, underscores, and an ending dollar  sign.   Variable  names are  case  insensitive.   Variables  can hold real numbers (IEEE double) or strings of up to 254 characters.  If  the variable  name ends with a "<code>$</code>" it holds strings, otherwise it holds numbers.  If a statement starts with  a  variable name then an implied <code><a href="#let">LET</a></code> is assumed.</p><hr><h3><a name="print">print VAL | STRINGVAL { [ , | ; ] VAL ... } { ; }</a></h3><h3>? VAL | STRINGVAL { [ , | ; ] VAL ... } { ; }</h3><h3>print # FNUM, VAL ...</h3><p>This  command  will print its parameters tab delimited.  If a semi-colon is used  between  parameters then  no  tab  is  inserted between the parameters. The print output  is  terminated  with  a  carriage return  unless the parameter list ends with a semi-colon.  If a file descriptor is given  then  output is redirected to the given file.  If a <code>tab(VAL);</code> is  found  in  a print statement, then print output will skip to the horizontal position  specified  by <code>VAL</code>.</p><h3><a name="printusing">print  {  #  FNUM, } using STRINGVAL ; VAR { [ , | ; ] VAR ... }</a></h3><p>Prints formatted numbers.  Legal characters for the format string <code>STRINGVAL</code> are: <code>+  *  $  #  .  E+</code>  and trailing spaces.</p><dl> <dt>Examples:</dt>  <dd><code>print using "**$###.##"; 1.23&nbsp;&nbsp;:' ****$1.23</code></dd>  <dd><code>print using "###.##"; 2.12345&nbsp;&nbsp;:' 2.12</code></dd>  <dd><code>print using "#.##E+##"; 2345.6&nbsp;:' 2.35E+03</code></dd></dl><hr><h3><a name="input">input STRINGVAR | VAR { , VAR }</a></h3><h3>input prompt ; { STRINGVAR | VAR { , VAR } }</h3>       <h3>input { # FNUM , } { STRINGVAR | VAR { , VAR } }</h3><p>Input  from  the console or from the file specified by <code>FNUM</code>. If the input is from the  console  then  a prompt string can optionally be printed.</p><h4>Note:</h4><p>All  input  to  string variables is "line input"; a whole input line will be read into one string variable.  The number of comma seperated numeric values in the input data must be less than or equal to the number of numeric variables in the <code>INPUT</code> statement. This <code>INPUT</code> usage is different from  other  versions Basic.</p><hr><h3><a name="get">get STRINGVAR</a></h3><p>Gets  one  character  from  the  console  keyboard. Blocking.</p><hr><h3><a name="fputbyte">fputbyte VAL, # FNUM</a></h3><p>Writes one byte to the file specified by <code>FNUM</code>.</p><hr><h3><a name="get_rnd">get # FNUM, VAL, TYPED-VAR</a></h3><p>Reads one record from a  random  access  file  into <code>VAR</code>.</p><hr><h3><a name="put_rnd">put # FNUM, VAL, TYPED-VAR</a></h3><p>Write  one record to a random access file from <code>VAR</code>.</p><hr><h3><a name="cls">cls</a></h3><p>Clear the terminals screen.  Leaves the  cursor  in the  upper  left corner.  <a name="home">For Applesoft BASIC fans, the "<code>home</code>" command will also do this.</a></p><hr><h3><a name="end">end</a></h3><p>Terminates program execution and  returns  to  the command prompt.  Not required.</p><hr><h3><a name="stop">stop</a></h3><p>Stops the execution of the program and returns to the command prompt.  Prints a "<code>Break...</code>" message.</p><hr><h3><a name="if">if</a> EXPR <a name="then">then</a> STATEMENT { : STATEMENT } { : <a name="else">else</a>  STATEMENT }</h3><h3>if EXPR then LINENUM</h3><h3>if EXPR</h3><p>The <code>IF</code> statement.  If the condition  is  true  then the  <code>STATEMENTS</code> after the <code>THEN</code> are executed and the statements after the <code>ELSE</code> are skipped.  If the condition  is  false  then  the  statements  after the "else" are executed instead.   If  the  item  after "<code>then</code>" is a line number then a goto is executed.</p><p>If  there  is  no <code>THEN</code> keyword on the same line and the condition is true, then statements are executed until  a  line starting with an <code><a name="endif">ENDIF</a></code> is found.  It false, then statements are  skipped  until  a  line starting with an <code>ENDIF</code> keyword is found (block <code>IF() ... ENDIF</code> statements).  <code>ELSE</code> and <code><a name="elseif">ELSEIF</a> ()</code> keywords may  be  used  on  lines  in between the <code>IF</code> and the <code>ENDIF</code> statements.</p><hr><h3><a name="for">for</a> VAR = EXPR <a name="to">to</a> EXPR { <a name="step">step</a> EXPR }</h3><p>Beginning of a <code>FOR-<a href="#next">NEXT</a></code> loop.  It takes a  starting value,  a  limit and an optional step argument.  If the step value is  negative,  the  variable  counts down.   The body of the loop is not executed if the end condition is true initially.</p><dl> <dt>Example:</dt>  <dd><code>for i=1 to 10 : print i, : next i</code></dd>  <dd><code> rem prints the numbers from 1 through 10</code></dd></dl><hr><h3><a name="next">next { VAR }</a></h3><p>End of a <code><a href="#for">FOR</a>-NEXT</code> loop.  If the termination  condi- tions  are  met then execution falls through to the following statement, otherwise execution returns to the  statement following the <code><a href="#for">FOR</a></code> statement with the corresponding index variable.  If  there  no  index variable parameter, the innermost <code><a href="#for">FOR</a></code> loop is used.</p><hr><h3><a name="exitfor">exit for</a></h3><p>Exits the current <code><a href="#for">FOR</a>-<a href="#next">NEXT</a></code> loop.</p><hr><h3><a name="while">while { EXPR }</a></h3><p>Start of a <code>WHILE</code> loop. The loop is  repeated  until <code>EXPR</code> is false. If <code>EXPR</code> is false at loop entry, then the loop is not executed . A  <code>WHILE</code>  loop  must  be terminated by a balancing <code><a href="#wend">WEND</a></code> statement.</p><hr><h3><a name="wend">wend { EXPR }</a></h3><p>Terminating  statement of a <code><a href="#while">WHILE</a></code> loop.  If <code>EXPR</code> is true then exit the loop.  Only one <code>WEND</code> is  allowed for each <code><a href="#while">WHILE</a></code>.  A <code><a href="#while">WHILE</a>-WEND</code> loop without a condition will loop forever.</p><hr><h3><a name="exitwhile">exit while</a></h3><p>Exits the current <code><a href="#while">WHILE</a>-<a href="#wend">WEND</a></code> loop.</p><hr><h3><a name="gosub">gosub LINENUM</a></h3><p>Transfer command to  a  line  number.  Save  return address so that the program can resume execution at the  statement  after  the  "<code>gosub</code>"  command.   The recursion  depth  is limited only by available memory.</p><hr><h3><a name="return">return</a></h3><p>Returns from the most recently  activated  subroutine call (which must have been called by <code><a href="#gosub">GOSUB</a></code>).</p><hr><h3><a name="goto">goto LINENUM</a></h3><p>This  statement  will  transfer control to the line number specified.  If the program is  not  running, then this command will begin execution at the spec- ified line  without  clearing  the  variables.   An "<code>Undefined line</code>"  error  will  occur  if  <code>LINENUM</code> doesn't exist in the program.</p><hr><h3><a name="ongoto">on EXPR goto LINENUM { , LINENUM ... }</a></h3><h3><a name="ongosub">on EXPR gosub LINENUM { , LINENUM ... }</a></h3><p>This command will execute either a <a href="#goto">goto</a> or a  <a href="#gosub">gosub</a> to  the  specified line number indexed by the value of <code>EXPR</code>.  If <code>EXPR</code> is  larger  than  the  number  of <code>LINENUM</code>s,  then  control  passes to the next statement.</p><hr><h3><a name="onerror">on error goto LINENUM</a></h3><p>If the error form is used, only one  linenumber  is allowed.   <code>LINENUM</code>  is the line to which control is transferred if an error occurs.   A  <code><a href="#goto">GOTO</a></code>  or  <code><a href="commands.html#cont">CONT</a></code> statement  can  be  used  to  resume execution.  An error inside  a  named  <code><a href="#sub">SUB</a></code>  subroutine  cannot  be resumed from or <code><a href="commands.html#cont">CONT</a></code>inued.</p><hr><h3><a name="sub">sub NAME ( VAR { , VAR ... } }</a></h3><p>Subroutine  entry.   May be called by a <code><a name="call">CALL</a></code> statement or by <code>NAME</code>. A <code>SUB</code> subroutine must be exited by a  <code><a href="#return">RETURN</a></code>  or  <code><a name="endsub">END SUB</a></code> statement.  There should be only one <code><a href="#return">RETURN</a></code> or <code>END SUB</code> statement per <code>SUB</code>  definition.  The variables in the <code>VAR</code> list become local variables. String and numeric arguments are  passed by  value;  array arguments must be pre-dimensioned and are passed by reference.</p><dl> <dt>Example:</dt>  <dd><code>110 x = foo (7, j)&nbsp;&nbsp;&nbsp;: rem Pass 7 and j by value.</code></dd>  <dd><code>...</code></dd>  <dd><code>2000 sub foo (x,y,z)&nbsp;: rem z is a local variable</code></dd>  <dd><code>2010 print x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: rem prints 7</code></dd>  <dd><code>...</code></dd>  <dd><code>2080 foo = y+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: rem return value</code></dd>  <dd><code>2090 end sub</code></dd></dl><p>Subroutine definitions may not be nested.</p><p><i>To return a value from a named subroutine terminated with <code>end sub</code>, set the name of the subroutine equal to the desired return value. Also, if the value to be returned is a string value, the subroutine name must end with a '<code>$</code>' character, as with all string variables.</i></p><hr><h3><a name="selectcase">select case EXPR</a></h3><p>Multi-way branch.  Executes  the  statements  after the  <code><a name="case">CASE</a></code>  statement  which matches the <code>SELECT CASE</code> expression, then skips to the <code><a name="endselect">END SELECT</a></code> statement. If  there is no match, and a <code><a name="caseelse">CASE ELSE</a></code> statement is present, then execution defaults to the  statements following the <code>CASE ELSE</code>.</p><dl> <dt>Example:</dt>  <dd><code>200 select case x</code></dd>  <dd><code>210   case 2</code></dd>  <dd><code>...</code></dd>  <dd><code> 230   case 3, 4</code></dd>  <dd><code>...</code></dd>  <dd><code>270   case else</code></dd>  <dd><code>...</code></dd>  <dd><code>290 end select</code></dd></dl><hr><h3><a name="dim">dim  VAR( d { , d { , d } } ) { , VAR( d { , d { , d } } ) }</a></h3><p>Dimension  an  array  or  list of arrays (string or numeric).  A maximum of 4 dimensions can  be  used. The  maximum dimension size is limited by available memory. Legal array subscripts are from  0  up  and including the dimension specified; <code>d+1</code> elements are allocated.  All arrays must be  dimensioned  before use.</p><dl> <dt>Example:</dt>   <dd><code>10 dim a(10)</code></dd>   <dd><code>20 for i=0 to 10</code></dd>   <dd><code>30   a(i) = i^2</code></dd>   <dd><code>40 next i</code></dd>   <dd><code>50 print a(5)</code></dd>   <dd><code>60 rem should print 25</code></dd></dl><hr><h3><a name="data">data ITEM { , ITEM }</a></h3><p><code>DATA</code>  statements  contain the data used in the <code><a href="#read">READ</a></code> statements. Items must be separated by commas.  The items  may be either numeric or string expressions, corresponding to the type of variable  being  read. Reading  the  wrong kind of object produces a "<code>Type mismatch</code>" error.  Strings must be encapsulated with quote marks.</p><hr><h3><a name="read">read VAR { , VAR }</a></h3><p>Read data from the <code><a href="#data">DATA</a></code> statements contained in the program. List items can be either string or numeric variables.  Reading  past  the  end  the  last <code><a href="#data">DATA</a></code> statement generates an error.</p><hr><h3><a name="restore">restore { LINENUM }</a></h3><p>The <code>RESTORE</code> statement causes the next <code><a href="#read">READ</a></code>  to  use the  first  <code><a href="#data">DATA</a></code>  statement  in  the program.  If a <code>LINENUM</code> is given then  the  <code><a href="#data">DATA</a></code>  statement  on  or after that particular line is used next.</p><hr><h3><a name="rem">rem or `</a></h3><p>A remark or comment statement.  Ignored by the program during execution, however a <code>REM</code> statement  can be the target of a <code><a href="#goto">GOTO</a></code> or <code><a href="#gosub">GOSUB</a></code>.</p><hr><h3><a name="open">open STRINGEXPR for { input|output|append } as # FNUM</a></h3><p>Open  a file. The <code>{ input|output|append }</code> parameter specifies whether the file is to be  read,  written or appended.  If <code>STRINGEXPR</code> is "<code>stdin</code>" for input or "<code>stdout</code>" for output then the console will  be  used instead  of  a file.  A "<code>file not found</code>" error will occur if a non-existant file  is  specified  in  an <code>OPEN</code>  for input statement.  <code>FNUM</code> must be an integer value between 0 and 8.</p><h3><a name="openrandom">open STRINGEXPR for random as # FNUM len = VAL</a></h3><p>Opens a random  access  file.   Only  <code><a href="#get_rnd">GET</a></code>  and  <code><a href="#put_rnd">PUT</a></code> statements  are  allowed  to  read  and write random access files.</p><h3><a name="openelse">open ... else goto LINENUM</a></h3><p>See <code><a href="#open">OPEN</a></code> command.  <code>LINENUM</code> is  the  line  to  which control  is  transferred  if  an error in opening a file occurs.  The variable <code><a href="numeric.html#erl">ERL</a></code> is set to  the  line number on which the file open error occured.</p><hr><h3><a name="close">close # FNUM</a></h3><p>Close  a  file.  Releases  the  file descriptor and flushes out all stored data.</p><hr><h3><a name="def">def fnNAME ( VAR { , VAR } ) = EXPR</a></h3><p>Define a user definable function.  Obsolete.</p><dl> <dt>Example:</dt>  <dd><code>10 def fnplus(x,y) = x+y</code></dd>  <dd><code>20 print fnplus(3,5)</code></dd>  <dd><code>30 rem - should print 8</code></dd></dl><hr><h3><a name="mat">mat ARRAY-VAR = EXPR</a></h3><p>Fills a 1 or 2 dimensional array  with  a  constant value given by <code>EXPR</code>.</p><h3>mat ARRAY-VAR = ARRAY-VAR</h3><p>Copys  a  2 dimensional array.  The dimensions must match.</p><h3><a name="matinvert">mat ARRAY-VAR = invert ARRAY-VAR</a></h3><h3><a name="matinvertelse">mat ARRAY-VAR = invert ARRAY-VAR else LINENUM</a></h3><p>Inverts a 2 dimensional square array.   <code>LINENUM</code>  is the   line  to  which control is transferred if the matrix is singular.</p><h3><a name="mattranspose">mat ARRAY-VAR = transpose ARRAY-VAR</a></h3><p>Transposes a 2 dimensional array.   The  dimensions of the first array must correspond to the transpose of the dimensions of the second array.</p><h3>mat ARRAY-VAR = ARRAY-VAR { + | * } { EXPR | ARRAY-VAR }</h3><p>Adds or multiplies a 2 dimensional array by  either an  expression  or  another  array.  The dimensions must be appropriate for matrix addition  or  matrix multiplication.</p><hr><h3><a name="matorigin">mat origin { 0 | 1 }</a></h3><p>Sets  the  matrix index origin to either 0 or 1 for all <code><a href="#mat">MAT</a></code> statements, including fill.  Defaults to 0.</p><hr><h3><a name="type">type CLASSNAME</a></h3><p>Creates  a  structure  definition type.  Each field requires a separate line.  Legal types are  string, integer,  longint  and double.  The definition must conclude with an <code><a name="endtype">END TYPE</a></code> statement.  Use  the  <code><a href="#dimasnew">DIM AS NEW</a></code>  statement to create records containing the structure specified by a <code>TYPE</code> statement.</p><dl> <dt>Example:</dt>  <dd><code>300 type person</code></dd>  <dd><code>310   name as string * 32</code></dd>  <dd><code>311     rem  31 chars in length</code></dd>  <dd><code>320   age as integer</code></dd>  <dd><code>312     rem  2 byte integers</code></dd>  <dd><code>330   weight as double</code></dd>  <dd><code>331     rem  8 byte doubles</code></dd>  <dd><code>340 end type</code></dd>  <dd><code>400 dim friend1 as new person</code></dd>  <dd><code>410 friend1.name = "Mark"</code></dd>  <dd><code>420 friend1.age = 13</code></dd>  <dd><code>430 print friend1.name, friend1.age</code></dd></dl><hr><h3><a name="class">class CLASSNAME</a> { <a name="extends">extends</a> SUPERCLASSNAME }</h3><p>Creates a class definition.  Class definitions  can then  be  used  to create objects with member functions (also called methods).  Classes inherit  members from superclasses (single inheritance).</p><dl> <dt>Example:</dt>  <dd><code>CLASS bar</code></dd>  <dd><code>&nbsp;y AS integer</code></dd>  <dd><code>&nbsp;z AS PRIVATE double&nbsp;&nbsp;&nbsp;' private data</code></dd>  <dd><code>&nbsp;s  AS  PUBLIC  string&nbsp;&nbsp;&nbsp;&nbsp;' public keyword optional</code></dd>  <dd><code>SUB blah(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' public member function</code></dd>  <dd><code>&nbsp;this.y = v + 7</code></dd>  <dd><code>END SUB</code></dd>  <dd><code><a name="endclass">END CLASS</a></code></dd>  <dd><code>DIM b AS NEW bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' create object b</code></dd>  <dd><code>CALL b.blah(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' send message "blah(1)" to b</code></dd></dl><p><code>CLASS</code> and <code><a href="#type">TYPE</a></code> definitions are global,  and  cannot be nested inside other class definitions or subroutines.</p><hr><h3><a name="dimasnew">dim VAR { ( INT ) } as new CLASSNAME</a></h3><p>Create a record (<code>TYPED-VAR</code>) or object using a  previously  defined  structure definition type created by <code><a href="#type">TYPE...END TYPE</a></code> or <code><a href="#class">CLASS...END CLASS</a></code>.  Optionally creates an array of records or objects.</p><hr><h3><a name="erase">erase VAR</a></h3><p>Un-dimensions a dimensioned array.  Frees memory.</p><hr><h3><a name="optiondegrees">option degrees</a></h3><p>Changes the trigonometric functions to take parameters and return results in degrees instead of radians.</p><hr><h3><a name="letmids">{ let } mid$( STRINGVAR, EXPR1, EXPR2 ) = STRINGEXPR</a></h3><p>Replace  the  sub-string  in <code>STRINGVAR</code>, starting at character position  <code>EXPR1</code>,  with  character  length <code>EXPR2</code>,  with  the  (<code>EXPR2</code> in length) string <code>STRINGEXPR</code>. See <code><a href="string.html#mid">MID$</a></code>.</p><h3><a name="letfield">{ let } field$( STRINGVAR, VAL { ,STRINGVAL } ) =  STRINGEXPR</a></h3><p>Replace the N-th field of <code>STRINGVAR</code>  with  <code>STRINGEXPR</code>. See <code><a href="string.html#field">FIELD$</a></code>.</p><hr><h3><a name="poke">poke ADDR_EXPR, DATA_EXPR</a></h3><p>Poke  a  byte  into a memory location. Unreasonable addresses can cause bus or segmentation errors.</p><hr><h3><a name="push">push VAR { , VAR ... }</a></h3><p>Pushes one or more expressions or variables onto an internal  stack.  Expressions can be returned using the <code><a href="numeric.html#pop">POP</a></code> function;  variables  can  be  returned  by using the <code><a href="#pop">POP</a></code> statement.</p><hr><h3><a name="pop">pop VAL</a></h3><p><code>POP</code>  statement  (see  also  <code><a href="numeric.html#pop">POP</a></code> function). Pops <code>VAL</code> variables off the  internal  stack,  restoring  the value of those variables to their pushed values.</p><hr><h3><a name="exec">exec(STRINGEXPR)</a></h3><p>Executes <code>STRINGEXPR</code> as  a  statement  or command. E.g., <code>exec("print " + "x")</code> will print the  value  of <code>x</code>.</p>            </body></html>